<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="index.css">

    <title>Fourier drawing</title>
    <meta name="description" content="Discrete Fourier Transform">
    <meta name="author" content="S.Fitzgerald">
</head>

<body>
    <!-- Main -->
    <main id="main">
        <canvas id="canvas" width="1000" height="550"></canvas>
    </main>
    <!-- end of Main -->

    <script src="./codingtrain.js"></script>

    <script>


        class Complex {
            constructor(re, im) {
                this.re = re;
                this.im = im;
            }

            get amplitude() {
                return Math.sqrt(this.re * this.re + this.im * this.im);
            }

            get phase() {
                return Math.atan2(this.im, this.re);
            }

            scale(factor) {
                return new Complex(
                    this.re * factor,
                    this.im * factor
                );
            }

            add(other) {
                return new Complex(
                    this.re + other.re,
                    this.im + other.im
                );
            }

            mult(other) {
                return new Complex(
                    this.re * other.re - this.im * other.im,
                    this.re * other.im + this.im * other.re
                );
            }

        }

        function dft(x) {

            const N = x.length;
            let X = [];

            for (let k = 0; k < N; k++) {
                let sum = new Complex(0, 0);
                for (let n = 0; n < N; n++) {
                    const phi = 2 * PI * k * n / N;
                    const c = new Complex(Math.cos(phi), -Math.sin(phi));
                    sum = sum.add(x[n].mult(c));
                }
                sum = sum.scale(1.0 / N);
                freq = k;
                amp = sum.amplitude;
                phase = sum.phase;
                X[k] = {
                    re: sum.re,
                    im: sum.im,
                    amp: amp,
                    freq: freq,
                    phase: phase
                };
            }
            return X;
        }

        function epiCycles(x, y, fourier, rotation = 0) {
            for (let i = 0; i < fourier.length; i++) {
                let cx = x;
                let cy = y;

                let freq = fourier[i].freq;
                let r = fourier[i].amp;
                let phase = fourier[i].phase;

                x += r * Math.cos(freq * t + phase + rotation);
                y += r * Math.sin(freq * t + phase + rotation);

                /* draw circle */
                ctx.beginPath();
                //ctx.strokeStyle = "white";
                ctx.arc(cx, cy, r, 0, TWO_PI);
                ctx.stroke();

                /* draw line from center to edge */
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(x, y);
                // draw a dot at end of line
                ctx.arc(x, y, dotRad, 0, TWO_PI);
                ctx.stroke();
            }
            return ({ x: x, y: y });
        }

        function draw() {

            ctx.fillStyle = 'rgb(220, 242, 255)';
            ctx.fillRect(0, 0, w, h);

            
            ctx.strokeStyle = 'white';
            pt1 = epiCycles(Cxo, Cyo, fourier);
            pathPt = { x: pt1.x, y: pt1.y };
            path.unshift(pathPt);

            ctx.strokeStyle = 'black';
            ctx.beginPath();
            for (i = 1; i < path.length; i++) {
                ctx.moveTo(path[i - 1].x, path[i - 1].y);
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();

            // draw line from last circle to wave
            ctx.beginPath();
            ctx.moveTo(pt1.x, pt1.y);
            ctx.lineTo(pathPt.x, pathPt.y - 4);
            ctx.stroke();

            t += dt;
            if (t > 2*TWO_PI) {
                t = 0;
                path.length = 0;
            }

            requestAnimationFrame(draw);
        }

        const PI = Math.PI;
        const TWO_PI = 2.0 * PI;
        const canvas = document.getElementById("canvas");
        const w = canvas.width;
        const h = canvas.height;
        const ctx = canvas.getContext('2d');

        const wave = []; // the path to replicate
        const skip = 4;
        for (let i = 0; i < drawing.length; i += skip) {
            wave.push(new Complex(drawing[i].x, drawing[i].y));
        }
        const fourier = dft(wave);
        fourier.sort((a, b) => b.amp - a.amp);

        const path = []; // the path generated from the Fourier series

        let t = 0;
        const dt = TWO_PI / fourier.length;

        // coords and dimensions for canvas drawing
        const dotRad = 2;
        const Cxo = w / 2;
        const Cyo = h / 2;

        draw();

    </script>

</body>

</html>